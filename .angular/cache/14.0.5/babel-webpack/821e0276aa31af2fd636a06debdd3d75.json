{"ast":null,"code":";\nexport class ParallelHasher {\n  constructor(workerUri, workerOptions) {\n    this._queue = [];\n    this._ready = true;\n    const self = this;\n\n    if (Worker) {\n      self._hashWorker = new Worker(workerUri, workerOptions);\n      self._hashWorker.onmessage = self._recievedMessage.bind(self);\n\n      self._hashWorker.onerror = err => {\n        self._ready = false;\n        console.error('Hash worker failure', err);\n      };\n    } else {\n      self._ready = false;\n      console.error('Web Workers are not supported in this browser');\n    }\n  }\n  /**\n   * Hash a blob of data in the worker\n   * @param blob Data to hash\n   * @returns Promise of the Hashed result\n   */\n\n\n  hash(blob) {\n    const self = this;\n    let promise;\n    promise = new Promise((resolve, reject) => {\n      self._queue.push({\n        blob,\n        resolve,\n        reject\n      });\n\n      self._processNext();\n    });\n    return promise;\n  }\n  /** Terminate any existing hash requests */\n\n\n  terminate() {\n    this._ready = false;\n\n    this._hashWorker.terminate();\n  } // Processes the next item in the queue\n\n\n  _processNext() {\n    if (this._ready && !this._processing && this._queue.length > 0) {\n      this._processing = this._queue.pop();\n\n      this._hashWorker.postMessage(this._processing.blob);\n    }\n  } // Hash result is returned from the worker\n\n\n  _recievedMessage(evt) {\n    var _a, _b;\n\n    const data = evt.data;\n\n    if (data.success) {\n      (_a = this._processing) === null || _a === void 0 ? void 0 : _a.resolve(data.result);\n    } else {\n      (_b = this._processing) === null || _b === void 0 ? void 0 : _b.reject(data.result);\n    }\n\n    this._processing = undefined;\n\n    this._processNext();\n  }\n\n}","map":{"version":3,"names":["ParallelHasher","constructor","workerUri","workerOptions","_queue","_ready","self","Worker","_hashWorker","onmessage","_recievedMessage","bind","onerror","err","console","error","hash","blob","promise","Promise","resolve","reject","push","_processNext","terminate","_processing","length","pop","postMessage","evt","_a","_b","data","success","result","undefined"],"sources":["C:/Users/Mardani.Amirhosein/Desktop/Mook/mook/MookAdmin/MookAdmin/node_modules/ts-md5/dist/esm/parallel_hasher.js"],"sourcesContent":[";\nexport class ParallelHasher {\n    constructor(workerUri, workerOptions) {\n        this._queue = [];\n        this._ready = true;\n        const self = this;\n        if (Worker) {\n            self._hashWorker = new Worker(workerUri, workerOptions);\n            self._hashWorker.onmessage = self._recievedMessage.bind(self);\n            self._hashWorker.onerror = (err) => {\n                self._ready = false;\n                console.error('Hash worker failure', err);\n            };\n        }\n        else {\n            self._ready = false;\n            console.error('Web Workers are not supported in this browser');\n        }\n    }\n    /**\n     * Hash a blob of data in the worker\n     * @param blob Data to hash\n     * @returns Promise of the Hashed result\n     */\n    hash(blob) {\n        const self = this;\n        let promise;\n        promise = new Promise((resolve, reject) => {\n            self._queue.push({\n                blob,\n                resolve,\n                reject,\n            });\n            self._processNext();\n        });\n        return promise;\n    }\n    /** Terminate any existing hash requests */\n    terminate() {\n        this._ready = false;\n        this._hashWorker.terminate();\n    }\n    // Processes the next item in the queue\n    _processNext() {\n        if (this._ready && !this._processing && this._queue.length > 0) {\n            this._processing = this._queue.pop();\n            this._hashWorker.postMessage(this._processing.blob);\n        }\n    }\n    // Hash result is returned from the worker\n    _recievedMessage(evt) {\n        var _a, _b;\n        const data = evt.data;\n        if (data.success) {\n            (_a = this._processing) === null || _a === void 0 ? void 0 : _a.resolve(data.result);\n        }\n        else {\n            (_b = this._processing) === null || _b === void 0 ? void 0 : _b.reject(data.result);\n        }\n        this._processing = undefined;\n        this._processNext();\n    }\n}\n"],"mappings":"AAAA;AACA,OAAO,MAAMA,cAAN,CAAqB;EACxBC,WAAW,CAACC,SAAD,EAAYC,aAAZ,EAA2B;IAClC,KAAKC,MAAL,GAAc,EAAd;IACA,KAAKC,MAAL,GAAc,IAAd;IACA,MAAMC,IAAI,GAAG,IAAb;;IACA,IAAIC,MAAJ,EAAY;MACRD,IAAI,CAACE,WAAL,GAAmB,IAAID,MAAJ,CAAWL,SAAX,EAAsBC,aAAtB,CAAnB;MACAG,IAAI,CAACE,WAAL,CAAiBC,SAAjB,GAA6BH,IAAI,CAACI,gBAAL,CAAsBC,IAAtB,CAA2BL,IAA3B,CAA7B;;MACAA,IAAI,CAACE,WAAL,CAAiBI,OAAjB,GAA4BC,GAAD,IAAS;QAChCP,IAAI,CAACD,MAAL,GAAc,KAAd;QACAS,OAAO,CAACC,KAAR,CAAc,qBAAd,EAAqCF,GAArC;MACH,CAHD;IAIH,CAPD,MAQK;MACDP,IAAI,CAACD,MAAL,GAAc,KAAd;MACAS,OAAO,CAACC,KAAR,CAAc,+CAAd;IACH;EACJ;EACD;AACJ;AACA;AACA;AACA;;;EACIC,IAAI,CAACC,IAAD,EAAO;IACP,MAAMX,IAAI,GAAG,IAAb;IACA,IAAIY,OAAJ;IACAA,OAAO,GAAG,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;MACvCf,IAAI,CAACF,MAAL,CAAYkB,IAAZ,CAAiB;QACbL,IADa;QAEbG,OAFa;QAGbC;MAHa,CAAjB;;MAKAf,IAAI,CAACiB,YAAL;IACH,CAPS,CAAV;IAQA,OAAOL,OAAP;EACH;EACD;;;EACAM,SAAS,GAAG;IACR,KAAKnB,MAAL,GAAc,KAAd;;IACA,KAAKG,WAAL,CAAiBgB,SAAjB;EACH,CAxCuB,CAyCxB;;;EACAD,YAAY,GAAG;IACX,IAAI,KAAKlB,MAAL,IAAe,CAAC,KAAKoB,WAArB,IAAoC,KAAKrB,MAAL,CAAYsB,MAAZ,GAAqB,CAA7D,EAAgE;MAC5D,KAAKD,WAAL,GAAmB,KAAKrB,MAAL,CAAYuB,GAAZ,EAAnB;;MACA,KAAKnB,WAAL,CAAiBoB,WAAjB,CAA6B,KAAKH,WAAL,CAAiBR,IAA9C;IACH;EACJ,CA/CuB,CAgDxB;;;EACAP,gBAAgB,CAACmB,GAAD,EAAM;IAClB,IAAIC,EAAJ,EAAQC,EAAR;;IACA,MAAMC,IAAI,GAAGH,GAAG,CAACG,IAAjB;;IACA,IAAIA,IAAI,CAACC,OAAT,EAAkB;MACd,CAACH,EAAE,GAAG,KAAKL,WAAX,MAA4B,IAA5B,IAAoCK,EAAE,KAAK,KAAK,CAAhD,GAAoD,KAAK,CAAzD,GAA6DA,EAAE,CAACV,OAAH,CAAWY,IAAI,CAACE,MAAhB,CAA7D;IACH,CAFD,MAGK;MACD,CAACH,EAAE,GAAG,KAAKN,WAAX,MAA4B,IAA5B,IAAoCM,EAAE,KAAK,KAAK,CAAhD,GAAoD,KAAK,CAAzD,GAA6DA,EAAE,CAACV,MAAH,CAAUW,IAAI,CAACE,MAAf,CAA7D;IACH;;IACD,KAAKT,WAAL,GAAmBU,SAAnB;;IACA,KAAKZ,YAAL;EACH;;AA5DuB"},"metadata":{},"sourceType":"module"}