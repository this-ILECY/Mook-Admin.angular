{"ast":null,"code":"import { Md5 } from './md5'; // Hashes any blob\n\nexport class Md5FileHasher {\n  constructor(_callback, // Callback to return the result\n  _async = true, // Async version is not always available in a web worker\n  _partSize = 1048576) {\n    this._callback = _callback;\n    this._async = _async;\n    this._partSize = _partSize;\n\n    this._configureReader();\n  }\n  /**\n   * Hash a blob of data in the worker\n   * @param blob Data to hash\n   */\n\n\n  hash(blob) {\n    const self = this;\n    self._blob = blob; // self._length = Math.ceil(blob.size / self._partSize);\n\n    self._part = 0;\n    self._md5 = new Md5();\n\n    self._processPart();\n  }\n\n  _fail() {\n    this._callback({\n      success: false,\n      result: 'data read failed'\n    });\n  }\n\n  _hashData(e) {\n    let self = this;\n\n    self._md5.appendByteArray(new Uint8Array(e.target.result));\n\n    if (self._part * self._partSize >= self._blob.size) {\n      self._callback({\n        success: true,\n        result: self._md5.end()\n      });\n    } else {\n      self._processPart();\n    }\n  }\n\n  _processPart() {\n    const self = this;\n    let endbyte = 0;\n    let current_part;\n    self._part += 1;\n\n    if (self._blob.size > self._partSize) {\n      // If blob bigger then part_size we will slice it up\n      endbyte = self._part * self._partSize;\n\n      if (endbyte > self._blob.size) {\n        endbyte = self._blob.size;\n      }\n\n      current_part = self._blob.slice((self._part - 1) * self._partSize, endbyte);\n    } else {\n      current_part = self._blob;\n    }\n\n    if (self._async) {\n      self._reader.readAsArrayBuffer(current_part);\n    } else {\n      setTimeout(() => {\n        try {\n          self._hashData({\n            target: {\n              result: self._reader.readAsArrayBuffer(current_part)\n            }\n          });\n        } catch (e) {\n          self._fail();\n        }\n      }, 0);\n    }\n  }\n\n  _configureReader() {\n    const self = this;\n\n    if (self._async) {\n      self._reader = new FileReader();\n      self._reader.onload = self._hashData.bind(self);\n      self._reader.onerror = self._fail.bind(self);\n      self._reader.onabort = self._fail.bind(self);\n    } else {\n      self._reader = new FileReaderSync();\n    }\n  }\n\n}","map":{"version":3,"names":["Md5","Md5FileHasher","constructor","_callback","_async","_partSize","_configureReader","hash","blob","self","_blob","_part","_md5","_processPart","_fail","success","result","_hashData","e","appendByteArray","Uint8Array","target","size","end","endbyte","current_part","slice","_reader","readAsArrayBuffer","setTimeout","FileReader","onload","bind","onerror","onabort","FileReaderSync"],"sources":["C:/Users/Mardani.Amirhosein/Desktop/Mook/mook/MookAdmin/MookAdmin/node_modules/ts-md5/dist/esm/md5_file_hasher.js"],"sourcesContent":["import { Md5 } from './md5';\n// Hashes any blob\nexport class Md5FileHasher {\n    constructor(_callback, // Callback to return the result\n    _async = true, // Async version is not always available in a web worker\n    _partSize = 1048576) {\n        this._callback = _callback;\n        this._async = _async;\n        this._partSize = _partSize;\n        this._configureReader();\n    }\n    /**\n     * Hash a blob of data in the worker\n     * @param blob Data to hash\n     */\n    hash(blob) {\n        const self = this;\n        self._blob = blob;\n        // self._length = Math.ceil(blob.size / self._partSize);\n        self._part = 0;\n        self._md5 = new Md5();\n        self._processPart();\n    }\n    _fail() {\n        this._callback({\n            success: false,\n            result: 'data read failed'\n        });\n    }\n    _hashData(e) {\n        let self = this;\n        self._md5.appendByteArray(new Uint8Array(e.target.result));\n        if (self._part * self._partSize >= self._blob.size) {\n            self._callback({\n                success: true,\n                result: self._md5.end()\n            });\n        }\n        else {\n            self._processPart();\n        }\n    }\n    _processPart() {\n        const self = this;\n        let endbyte = 0;\n        let current_part;\n        self._part += 1;\n        if (self._blob.size > self._partSize) { // If blob bigger then part_size we will slice it up\n            endbyte = self._part * self._partSize;\n            if (endbyte > self._blob.size) {\n                endbyte = self._blob.size;\n            }\n            current_part = self._blob.slice((self._part - 1) * self._partSize, endbyte);\n        }\n        else {\n            current_part = self._blob;\n        }\n        if (self._async) {\n            self._reader.readAsArrayBuffer(current_part);\n        }\n        else {\n            setTimeout(() => {\n                try {\n                    self._hashData({\n                        target: {\n                            result: self._reader.readAsArrayBuffer(current_part)\n                        },\n                    });\n                }\n                catch (e) {\n                    self._fail();\n                }\n            }, 0);\n        }\n    }\n    _configureReader() {\n        const self = this;\n        if (self._async) {\n            self._reader = new FileReader();\n            self._reader.onload = self._hashData.bind(self);\n            self._reader.onerror = self._fail.bind(self);\n            self._reader.onabort = self._fail.bind(self);\n        }\n        else {\n            self._reader = new FileReaderSync();\n        }\n    }\n}\n"],"mappings":"AAAA,SAASA,GAAT,QAAoB,OAApB,C,CACA;;AACA,OAAO,MAAMC,aAAN,CAAoB;EACvBC,WAAW,CAACC,SAAD,EAAY;EACvBC,MAAM,GAAG,IADE,EACI;EACfC,SAAS,GAAG,OAFD,EAEU;IACjB,KAAKF,SAAL,GAAiBA,SAAjB;IACA,KAAKC,MAAL,GAAcA,MAAd;IACA,KAAKC,SAAL,GAAiBA,SAAjB;;IACA,KAAKC,gBAAL;EACH;EACD;AACJ;AACA;AACA;;;EACIC,IAAI,CAACC,IAAD,EAAO;IACP,MAAMC,IAAI,GAAG,IAAb;IACAA,IAAI,CAACC,KAAL,GAAaF,IAAb,CAFO,CAGP;;IACAC,IAAI,CAACE,KAAL,GAAa,CAAb;IACAF,IAAI,CAACG,IAAL,GAAY,IAAIZ,GAAJ,EAAZ;;IACAS,IAAI,CAACI,YAAL;EACH;;EACDC,KAAK,GAAG;IACJ,KAAKX,SAAL,CAAe;MACXY,OAAO,EAAE,KADE;MAEXC,MAAM,EAAE;IAFG,CAAf;EAIH;;EACDC,SAAS,CAACC,CAAD,EAAI;IACT,IAAIT,IAAI,GAAG,IAAX;;IACAA,IAAI,CAACG,IAAL,CAAUO,eAAV,CAA0B,IAAIC,UAAJ,CAAeF,CAAC,CAACG,MAAF,CAASL,MAAxB,CAA1B;;IACA,IAAIP,IAAI,CAACE,KAAL,GAAaF,IAAI,CAACJ,SAAlB,IAA+BI,IAAI,CAACC,KAAL,CAAWY,IAA9C,EAAoD;MAChDb,IAAI,CAACN,SAAL,CAAe;QACXY,OAAO,EAAE,IADE;QAEXC,MAAM,EAAEP,IAAI,CAACG,IAAL,CAAUW,GAAV;MAFG,CAAf;IAIH,CALD,MAMK;MACDd,IAAI,CAACI,YAAL;IACH;EACJ;;EACDA,YAAY,GAAG;IACX,MAAMJ,IAAI,GAAG,IAAb;IACA,IAAIe,OAAO,GAAG,CAAd;IACA,IAAIC,YAAJ;IACAhB,IAAI,CAACE,KAAL,IAAc,CAAd;;IACA,IAAIF,IAAI,CAACC,KAAL,CAAWY,IAAX,GAAkBb,IAAI,CAACJ,SAA3B,EAAsC;MAAE;MACpCmB,OAAO,GAAGf,IAAI,CAACE,KAAL,GAAaF,IAAI,CAACJ,SAA5B;;MACA,IAAImB,OAAO,GAAGf,IAAI,CAACC,KAAL,CAAWY,IAAzB,EAA+B;QAC3BE,OAAO,GAAGf,IAAI,CAACC,KAAL,CAAWY,IAArB;MACH;;MACDG,YAAY,GAAGhB,IAAI,CAACC,KAAL,CAAWgB,KAAX,CAAiB,CAACjB,IAAI,CAACE,KAAL,GAAa,CAAd,IAAmBF,IAAI,CAACJ,SAAzC,EAAoDmB,OAApD,CAAf;IACH,CAND,MAOK;MACDC,YAAY,GAAGhB,IAAI,CAACC,KAApB;IACH;;IACD,IAAID,IAAI,CAACL,MAAT,EAAiB;MACbK,IAAI,CAACkB,OAAL,CAAaC,iBAAb,CAA+BH,YAA/B;IACH,CAFD,MAGK;MACDI,UAAU,CAAC,MAAM;QACb,IAAI;UACApB,IAAI,CAACQ,SAAL,CAAe;YACXI,MAAM,EAAE;cACJL,MAAM,EAAEP,IAAI,CAACkB,OAAL,CAAaC,iBAAb,CAA+BH,YAA/B;YADJ;UADG,CAAf;QAKH,CAND,CAOA,OAAOP,CAAP,EAAU;UACNT,IAAI,CAACK,KAAL;QACH;MACJ,CAXS,EAWP,CAXO,CAAV;IAYH;EACJ;;EACDR,gBAAgB,GAAG;IACf,MAAMG,IAAI,GAAG,IAAb;;IACA,IAAIA,IAAI,CAACL,MAAT,EAAiB;MACbK,IAAI,CAACkB,OAAL,GAAe,IAAIG,UAAJ,EAAf;MACArB,IAAI,CAACkB,OAAL,CAAaI,MAAb,GAAsBtB,IAAI,CAACQ,SAAL,CAAee,IAAf,CAAoBvB,IAApB,CAAtB;MACAA,IAAI,CAACkB,OAAL,CAAaM,OAAb,GAAuBxB,IAAI,CAACK,KAAL,CAAWkB,IAAX,CAAgBvB,IAAhB,CAAvB;MACAA,IAAI,CAACkB,OAAL,CAAaO,OAAb,GAAuBzB,IAAI,CAACK,KAAL,CAAWkB,IAAX,CAAgBvB,IAAhB,CAAvB;IACH,CALD,MAMK;MACDA,IAAI,CAACkB,OAAL,GAAe,IAAIQ,cAAJ,EAAf;IACH;EACJ;;AApFsB"},"metadata":{},"sourceType":"module"}